<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>NPC Chat Test</title>
  <style>
    body { margin: 0; overflow: hidden; background: #222; }
    #overlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.7);
      color: white;
      font-size: 24px;
      z-index: 10;
      cursor: pointer;
    }
    #chat {
      position: fixed;
      bottom: 60px;
      right: 20px;
      width: 250px;
      max-height: 200px;
      overflow-y: auto;
      background: rgba(0,0,0,0.8);
      border: 1px solid #666;
      color: #fff;
      padding: 10px;
      font-size: 14px;
      display: none;
    }
    #chatInput {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 250px;
      display: none;
      padding: 6px;
      background: rgba(255,255,255,0.1);
      border: none;
      color: #fff;
      outline: none;
      font-size: 14px;
    }
  </style>
</head>
<body>

<div id="overlay">Click to Start</div>
<div id="chat"></div>
<input id="chatInput" type="text" placeholder="Type..." />

<script type="module">
  import * as THREE from "https://esm.sh/three@0.161.0";
  import { PointerLockControls } from "https://esm.sh/three@0.161.0/examples/jsm/controls/PointerLockControls.js";
  import { FBXLoader } from "https://esm.sh/three@0.161.0/examples/jsm/loaders/FBXLoader.js";

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x444444);

  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 1.8, 5);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1));

  const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(50, 50),
    new THREE.MeshStandardMaterial({ color: 0x333333 })
  );
  floor.rotation.x = -Math.PI / 2;
  scene.add(floor);

  // NPC FBX Model
  let npcMesh = null;
  let mixer = null;
  const clock = new THREE.Clock();

  const loader = new FBXLoader();
  loader.load(
    "./models/sad_idle.fbx",
    object => {
      npcMesh = object;
      npcMesh.scale.set(0.01, 0.01, 0.01);
      npcMesh.position.set(0, 0, -5);
      npcMesh.rotation.y = Math.PI;
      scene.add(npcMesh);

      mixer = new THREE.AnimationMixer(npcMesh);
      if (object.animations && object.animations.length > 0) {
        const anim = mixer.clipAction(object.animations[0]);
        anim.play();
      }
    },
    undefined,
    err => console.error("FBX failed to load:", err)
  );

  // Controls
  const controls = new PointerLockControls(camera, document.body);
  const overlay = document.getElementById("overlay");
  overlay.addEventListener("click", () => controls.lock());
  controls.addEventListener("lock", () => overlay.style.display = "none");
  controls.addEventListener("unlock", () => overlay.style.display = "flex");

  const keys = { KeyW:false, KeyA:false, KeyS:false, KeyD:false };
  document.addEventListener("keydown", e => { if (keys[e.code] !== undefined) keys[e.code] = true; if (e.code === "KeyE") interact(); });
  document.addEventListener("keyup", e => { if (keys[e.code] !== undefined) keys[e.code] = false; });

  let prev = performance.now();
  const velocity = new THREE.Vector3();
  const direction = new THREE.Vector3();

  function movementUpdate() {
    if (!controls.isLocked) return;

    const time = performance.now();
    const delta = (time - prev) / 1000;
    prev = time;

    velocity.x -= velocity.x * 5 * delta;
    velocity.z -= velocity.z * 5 * delta;

    direction.z = Number(keys.KeyS) - Number(keys.KeyW);
    direction.x = Number(keys.KeyD) - Number(keys.KeyA);
    direction.normalize();

    const speed = 15;
    velocity.z += direction.z * speed * delta;
    velocity.x += direction.x * speed * delta;

    controls.moveRight(-velocity.x * delta);
    controls.moveForward(-velocity.z * delta);

    camera.position.y = 1.8;
  }

  const chatBox = document.getElementById("chat");
  const chatInput = document.getElementById("chatInput");

  function interact() {
    if (!npcMesh) return;
    const dist = npcMesh.position.distanceTo(camera.position);
    if (dist < 3) {
      chatBox.style.display = "block";
      chatInput.style.display = "block";
      chatInput.focus();
      addMessage("NPC", "Hey. I’m just… standing here.");
    }
  }

  function addMessage(sender, text) {
    chatBox.innerHTML += `<div><strong>${sender}:</strong> ${text}</div>`;
    chatBox.scrollTop = chatBox.scrollHeight;
  }

  chatInput.addEventListener("keydown", e => {
    if (e.key === "Enter" && chatInput.value.trim()) {
      const msg = chatInput.value;
      addMessage("You", msg);
      chatInput.value = "";

      const replies = [
        "Right...",
        "Honestly same.",
        "Standing is my personal brand.",
        "Do you ever question reality?",
        "Everything is a placeholder until it's not."
      ];
      addMessage("NPC", replies[Math.floor(Math.random() * replies.length)]);
    }
  });

  function animate() {
    requestAnimationFrame(animate);
    movementUpdate();
    if (mixer) mixer.update(clock.getDelta());
    renderer.render(scene, camera);
  }
  animate();

  window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>

</body>
</html>
